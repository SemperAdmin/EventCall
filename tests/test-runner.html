<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>EventCall Security Test Runner</title>
  <style>
    body { font-family: system-ui, sans-serif; }
    .test-pass { color: #0a0; }
    .test-fail { color: #a00; }
    .test-skip { color: #888; }
    #report { margin: 12px 0; }
  </style>
</head>
<body>
  <h1>EventCall Security Test Runner</h1>
  <div id="report"></div>
  <div id="test-output" style="white-space: pre-wrap; font-family: monospace;"></div>

  <script>
    // Set test mode flag to prevent auth initialization
    window.__TEST_MODE__ = true;

    // Minimal expect/assert implementation for our tests
    (function(){
      function Expect(actual, neg) { this.actual = actual; this.neg = !!neg; }
      Expect.prototype._assert = function(cond, msg) {
        if (this.neg ? cond : !cond) throw new Error(msg || 'Assertion failed');
        return this;
      };
      Object.defineProperty(Expect.prototype, 'to', { get() { return this; } });
      Object.defineProperty(Expect.prototype, 'be', { get() { return this; } });
      Object.defineProperty(Expect.prototype, 'at', { get() { return this; } });
      Object.defineProperty(Expect.prototype, 'not', { get() { return new Expect(this.actual, !this.neg); } });
      Expect.prototype.exist = function() {
        return this._assert(this.actual != null, 'Expected value to exist');
      };
      Expect.prototype.a = function(type) {
        const t = typeof this.actual;
        return this._assert(t === type, `Expected type ${type}, got ${t}`);
      };
      Expect.prototype.include = function(part) {
        const a = this.actual;
        const has = typeof a === 'string' ? a.includes(part) : Array.isArray(a) ? a.indexOf(part) !== -1 : false;
        return this._assert(has, `Expected to include ${part}`);
      };
      Expect.prototype.equal = function(expected) {
        return this._assert(this.actual === expected, `Expected ${expected}, got ${this.actual}`);
      };
      Expect.prototype.least = function(min) {
        const ok = Number(this.actual) >= Number(min);
        return this._assert(ok, `Expected ${this.actual} to be >= ${min}`);
      };
      window.expect = function(actual) { return new Expect(actual); };
    })();

    // Minimal BDD runner
    (function(){
      const tests = [];
      const befores = [];
      const reportEl = document.getElementById('report');

      window.describe = function(title, fn) { fn(); };
      window.beforeEach = function(fn) { befores.push(fn); };
      window.it = function(title, fn) { tests.push({ title, fn }); };

      async function runTests() {
        const results = { tests: [], stats: { passes: 0, failures: 0, pending: 0, duration: 0 } };
        const start = performance.now();
        for (const t of tests) {
          let state = 'passed';
          let error = null;
          let skipped = false;
          const ctx = { skip: () => { skipped = true; } };
          try {
            for (const b of befores) { await b(); }
            const ret = t.fn.call(ctx);
            if (ret && typeof ret.then === 'function') await ret;
          } catch (e) {
            state = 'failed';
            error = String(e);
          }
          if (skipped) { state = 'skipped'; }
          results.tests.push({ title: t.title, state, error });
          if (state === 'passed') results.stats.passes++;
          else if (state === 'failed') results.stats.failures++;
          else results.stats.pending++;
        }
        results.stats.duration = Math.round(performance.now() - start);
        window.__TEST_RESULTS__ = results;
        window.MOCHA_DONE = true;
        const out = document.getElementById('test-output');
        out.textContent = JSON.stringify(results, null, 2);
        // Basic HTML report
        const frag = document.createDocumentFragment();
        const summary = document.createElement('div');
        summary.textContent = `Passes: ${results.stats.passes}  Failures: ${results.stats.failures}  Skipped: ${results.stats.pending}  Duration: ${results.stats.duration}ms`;
        frag.appendChild(summary);
        const list = document.createElement('ul');
        for (const r of results.tests) {
          const li = document.createElement('li');
          li.textContent = r.title + (r.error ? ` â€” ${r.error}` : '');
          li.className = r.state === 'passed' ? 'test-pass' : r.state === 'failed' ? 'test-fail' : 'test-skip';
          list.appendChild(li);
        }
        frag.appendChild(list);
        reportEl.innerHTML = '';
        reportEl.appendChild(frag);
      }
      window.addEventListener('DOMContentLoaded', runTests);
    })();
  </script>

  <!-- Load minimal app modules needed for tests -->
  <script src="../js/config.js"></script>
  <script src="../js/utils.js"></script>
  <script src="../js/validation.js"></script>
  <script src="../js/csrf.js"></script>
  <script src="../js/rate-limiter.js"></script>
  <script src="../js/user-auth.js"></script>
  <script src="../js/error-handler.js"></script>
  <script src="../js/router.js"></script>

  <!-- Security Tests -->
  <script src="./security-tests.spec.js"></script>
  <!-- Navigation Tests -->
  <script src="./navigation-tests.spec.js"></script>
</body>
</html>
